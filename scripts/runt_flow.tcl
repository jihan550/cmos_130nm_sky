#!/usr/bin/env tclsh
#
# Usage:
#   ./run_flow.tcl -t <rtl1.v rtl2.v ...> -tb <tb.v> -f <output_dir>
#
# Example:
#   ./run_flow.tcl \
#       -t top/rtl/fsm_demo/fsm_demo.v \
#       -tb top/sim/rtl/fsm_demo_tb.v \
#       -f build/fsm_demo
#
# Assumptions:
#   - Top RTL module name = <design_name>  (taken from output_dir tail, e.g. fsm_demo)
#   - Testbench top module = <design_name>_tb  (e.g. fsm_demo_tb)
#   - Testbench calls:
#       initial begin
#           $dumpfile("wave.vcd");
#           $dumpvars(0, <tb_top or dut>);
#       end
#
# Optional (recommended for SPICE / techmapping to sky130):
#   export SKY130_HD_LIB="/home/jihan/eda/open_pdks/sky130/sky130A/libs.ref/sky130_fd_sc_hd/lib/sky130_fd_sc_hd__tt_025C_1v80.lib"
#

# ============================================================
# Command Line Argument Parsing
# ============================================================

set rtl_files {}
set tb_file ""
set out_dir ""
set i 0

while {$i < $argc} {
    set arg [lindex $argv $i]

    switch -- $arg {
        "-t" {
            incr i
            # Collect all RTL files until the next flag
            while {$i < $argc && ![string match "-*" [lindex $argv $i]]} {
                lappend rtl_files [lindex $argv $i]
                incr i
            }
            incr i -1
        }

        "-tb" {
            incr i
            if {$i >= $argc} {
                puts "ERROR: -tb requires a value"
                exit 1
            }
            set tb_file [lindex $argv $i]
        }

        "-f" {
            incr i
            if {$i >= $argc} {
                puts "ERROR: -f requires a value"
                exit 1
            }
            set out_dir [lindex $argv $i]
        }

        default {
            puts "Unknown option: $arg"
            puts "Usage: $argv0 -t <rtl1.v rtl2.v ...> -tb <tb.v> -f <output_folder>"
            exit 1
        }
    }

    incr i
}

if {$rtl_files eq {} || $tb_file eq "" || $out_dir eq ""} {
    puts "ERROR: Missing required arguments."
    puts "Usage: $argv0 -t <rtl1.v rtl2.v ...> -tb <tb.v> -f <output_folder>"
    exit 1
}

# Design name = last path component of out_dir
set design_name [file tail [string trimright $out_dir "/"]]

# Assume top modules by convention
set rtl_top $design_name
set tb_top  "${design_name}_tb"

# ============================================================
# Directories
# ============================================================

set sim_dir   "$out_dir/sim"
set synth_dir "$out_dir/synth"

file mkdir $out_dir
file mkdir $sim_dir
file mkdir $synth_dir

set sim_exe  "simv"
set vcd_file "wave.vcd"

# ============================================================
# Helper Function
# ============================================================

proc run_cmd {cmd} {
    puts ">>> $cmd"
    flush stdout
    if {[catch {eval exec $cmd} result]} {
        puts "!! ERROR: $result"
        exit 1
    } else {
        puts $result
    }
}

# ============================================================
# 1. RTL SIMULATION
# ============================================================

puts "\n===== RTL SIMULATION ====="
puts "RTL Files : $rtl_files"
puts "Testbench : $tb_file"
puts "Top TB    : $tb_top"

# Build iverilog command
set compile_cmd [concat \
    iverilog -g2012 \
    -o "$sim_dir/$sim_exe" \
    -s $tb_top \
    $rtl_files $tb_file]

run_cmd $compile_cmd

set cwd [pwd]
cd $sim_dir

run_cmd "vvp $sim_exe"

if {[file exists $vcd_file]} {
    run_cmd "gtkwave $vcd_file &"
} else {
    puts "!! WARNING: $vcd_file not found. Did your testbench call \$dumpfile(\"wave.vcd\")?"
}

cd $cwd

# ============================================================
# 2. YOSYS SYNTHESIS + SPICE FOR XSCHEM
# ============================================================

puts "\n===== YOSYS SYNTHESIS ====="

set yosys_script "$synth_dir/synth.ys"
set yosys_out_v  "$synth_dir/${design_name}_synth.v"
set yosys_out_j  "$synth_dir/${design_name}.json"
set yosys_out_sp "$synth_dir/${design_name}_xschem.spice"

# Get SKY130 liberty path from env if available
set have_sky130 0
if {[info exists ::env(SKY130_HD_LIB)]} {
    set sky130_lib $::env(SKY130_HD_LIB)
    set have_sky130 1
    puts "Using SKY130 liberty: $sky130_lib"
} else {
    puts "NOTE: SKY130_HD_LIB not set; synthesis will not be tech-mapped to sky130_fd_sc_hd."
}

set fh [open $yosys_script "w"]

puts $fh "# Auto-generated by run_flow.tcl"
puts $fh "read_verilog [join $rtl_files \" \"]"
puts $fh "hierarchy -check -top $rtl_top"
puts $fh "proc; opt; fsm; opt; techmap; opt"

if {$have_sky130} {
    puts $fh "read_liberty -lib $sky130_lib"
    puts $fh "dfflibmap -liberty $sky130_lib"
    puts $fh "abc       -liberty $sky130_lib"
}

puts $fh "synth -top $rtl_top"
puts $fh "opt_clean"
puts $fh "stat"

puts $fh "write_verilog $yosys_out_v"
puts $fh "write_json    $yosys_out_j"

# SPICE netlist (for xschem/ngspice)
# Requires reasonably recent yosys that supports -noattr/-pos/-neg
puts $fh "write_spice -noattr -pos VDD -neg VSS $yosys_out_sp"

close $fh

run_cmd "yosys -s $yosys_script"

puts "\n===== DONE ====="
puts "Simulation output : $sim_dir"
puts "Synthesis output  : $synth_dir"
puts "SPICE for xschem  : $yosys_out_sp"
